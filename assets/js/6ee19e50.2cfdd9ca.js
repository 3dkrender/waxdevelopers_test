"use strict";(self.webpackChunkwaxdevelopers=self.webpackChunkwaxdevelopers||[]).push([[2173],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>p});var a=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,o=e.originalType,l=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),d=c(n),h=s,p=d["".concat(l,".").concat(h)]||d[h]||u[h]||o;return n?a.createElement(p,i(i({ref:t},m),{},{components:n})):a.createElement(p,i({ref:t},m))}));function p(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=n.length,i=new Array(o);i[0]=h;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[d]="string"==typeof e?e:s,i[1]=r;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2677:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var a=n(7462),s=(n(7294),n(3905));const o={title:"Minting atomicassets NFTs",nav_order:40,layout:"default",parent:"How-To AtomicAssets",grand_parent:"Tutorials",has_children:!1,"lang-ref":"Minting atomicassets NFTs",lang:"es"},i=void 0,r={unversionedId:"tutorials/howto_atomicassets/mint_nft",id:"tutorials/howto_atomicassets/mint_nft",title:"Minting atomicassets NFTs",description:"After having created the structure of the collection, it is time to start operating with the NFTs. To do so, the atomicassets smart contract offers us these actions:",source:"@site/docs/tutorials/howto_atomicassets/mint_nft.md",sourceDirName:"tutorials/howto_atomicassets",slug:"/tutorials/howto_atomicassets/mint_nft",permalink:"/waxdevelopers_test/docs/tutorials/howto_atomicassets/mint_nft",draft:!1,editUrl:"https://github.com/3dkrender/waxdeveloper_test/tree/main/docs/tutorials/howto_atomicassets/mint_nft.md",tags:[],version:"current",frontMatter:{title:"Minting atomicassets NFTs",nav_order:40,layout:"default",parent:"How-To AtomicAssets",grand_parent:"Tutorials",has_children:!1,"lang-ref":"Minting atomicassets NFTs",lang:"es"},sidebar:"tutorialSidebar",previous:{title:"Collection structure",permalink:"/waxdevelopers_test/docs/tutorials/howto_atomicassets/collection_struct"},next:{title:"Modifying mutable data for AA",permalink:"/waxdevelopers_test/docs/tutorials/howto_atomicassets/mutabledata"}},l={},c=[{value:"Minting NFTs",id:"minting-nfts",level:2},{value:"What does the NFT we have created look like?",id:"what-does-the-nft-we-have-created-look-like",level:2}],m={toc:c},d="wrapper";function u(e){let{components:t,...o}=e;return(0,s.kt)(d,(0,a.Z)({},m,o,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After having created the structure of the collection, it is time to start operating with the NFTs. To do so, the atomicassets smart contract offers us these actions:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"mintasset: mint a new NFT."),(0,s.kt)("li",{parentName:"ul"},"transfer: Send one or more NFTs from one account to another."),(0,s.kt)("li",{parentName:"ul"},"burnasset: Destroy (burn) the NFT."),(0,s.kt)("li",{parentName:"ul"},"setassetdata: Set or modify the mutable data of an NFT."),(0,s.kt)("li",{parentName:"ul"},"backasset: Associate tokens to the NFT that will be released when the NFT is destroyed.")),(0,s.kt)("h2",{id:"minting-nfts"},"Minting NFTs"),(0,s.kt)("p",null,"Minting NFTs consists of creating instances from a reference template, which contains the information that will be replicated in each new instance, as we have already seen in previous documents."),(0,s.kt)("p",null,"The parameters of the action would be the following:"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"AtomicAsssets mintasset",src:n(3780).Z,width:"487",height:"789"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"authorised_minter: Account authorised by the collection."),(0,s.kt)("li",{parentName:"ul"},"collection_name: Name of the collection to which the NFT will belong."),(0,s.kt)("li",{parentName:"ul"},"schema_name: Name of the schema in which the data types that will define the NFTs are declared."),(0,s.kt)("li",{parentName:"ul"},"template_id: Identifier of the template that contains all the immutable data of each copy of NFT that will be minted with this template."),(0,s.kt)("li",{parentName:"ul"},"new_asset_owner: Account name that will receive ownership of the newly created NFT. The authorised account can create an NFT directly in a target account other than its own without the need for transfers."),(0,s.kt)("li",{parentName:"ul"},"immutable_data: Additional immutable data. This data is not in the template, but its types must be defined in the schema."),(0,s.kt)("li",{parentName:"ul"},"mutable_data: Initial mutable data. Mutable data are not defined in the template, but their types must be defined in the schema. Mutable data can be added or modified in the NFT at any time, so it is not mandatory to create it at this point."),(0,s.kt)("li",{parentName:"ul"},"tokens_to_back: List of tokens that will be associated to the NFT from the moment of its creation and that will be released when the NFT is destroyed. ")),(0,s.kt)("p",null,"Immutable_data and mutable_data are defined as objects of type ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/pinknetworkx/atomicassets-contract/wiki/Custom-Types#attribute_map"},"ATTRIBUTE_MAP"),", already seen in previous documents."),(0,s.kt)("p",null,'We can consult the "config" table of the smart contract atomicassets to check which tokens are currently allowed to be associated with NFTs as not all of them are allowed.'),(0,s.kt)("p",null,"AtomicAsssets config](/img/tutorials/howto_atomicassets/atomicassets_supportedtokens.png)"),(0,s.kt)("p",null,"If you need to associate other types of tokens to an NFT, or even other NFTs, you can use third-party utilities, such as Blenderizer V.2\n:::"),(0,s.kt)("p",null,'Next we are going to create a "Player" NFT from the template we created in the previous document. In the schema declaration we include several fields that were not used by the template; points, life and shield, because this data will change over time, so it will be mutable data. '),(0,s.kt)("p",null,"Let's look at the preparation of the data to create the NFT:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'const authorized_minter = \'arpegiator21\';\nconst collection_name = \'arpecol11111\';\nconst schema_name = \'player\';\nconst template_id = 447413;\nconst new_asset_owner = \'arpegiator21\';\nconst immutable_data = []; \nconst mutable_data = [\n    {\n        key: "points",\n        value: ["uint32", 0],\n    },\n    {\n        key: "life",\n        value: ["uint16", 100],\n    },\n    {\n        key: "shield",\n        value: ["uint16", 20],\n    }\n];\nconst tokens_to_back = [];\n\n(async () => {\n    const result = await mintAsset(\n        authorized_minter,\n        collection_name,\n        schema_name,\n        template_id,\n        new_asset_owner,\n        immutable_data,\n        mutable_data,\n        tokens_to_back\n    );\n    console.log(result);\n})();\n')),(0,s.kt)("p",null,"And call to action:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'/**\n * Mint new asset\n */\nconst mintAsset = async (\n  authorized_minter,\n  collection_name,\n  schema_name,\n  template_id,\n  new_asset_owner,\n  immutable_data,\n  mutable_data,\n  tokens_to_back\n) => {\n  try {\n    const result = await apiRpc.transact(\n      {\n        actions: [\n          {\n            account: "atomicassets",\n            name: "mintasset",\n            authorization: [\n              {\n                actor: authorized_minter,\n                permission: "active",\n              },\n            ],\n            data: {\n              authorized_minter: authorized_minter,\n              collection_name: collection_name,\n              schema_name: schema_name,\n              template_id: template_id,\n              new_asset_owner: new_asset_owner,\n              immutable_data: immutable_data,\n              mutable_data: mutable_data,\n              tokens_to_back: tokens_to_back\n            },\n          },\n        ],\n      }, TAPOS\n    );\n    return result;\n  } catch (error) {\n    console.log(error);\n  }\n}\n')),(0,s.kt)("p",null,"Again, if we trace the ID of the transaction performed, we can get the ID of the new NFT"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"AtomicAsssets transfer traces",src:n(1026).Z,width:"1054",height:"771"})),(0,s.kt)("p",null,"And if we go to an NFT browser, like the AtomicHub marketplace, we can see our NFT."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"AtomicAsssets new NFT",src:n(4784).Z,width:"1381",height:"925"})),(0,s.kt)("h2",{id:"what-does-the-nft-we-have-created-look-like"},"What does the NFT we have created look like?"),(0,s.kt)("p",null,"We can access the collections table of the smart contract atomicassets to check it (enter the collection name in the search filter):"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"AtomicAsssets mintasset",src:n(7922).Z,width:"1184",height:"700"})),(0,s.kt)("p",null,"We can also access the schema table to see the schema we have created (this time we will use the name of the collection to set the scope of the search):"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"AtomicAsssets mintasset",src:n(7161).Z,width:"1174",height:"697"})),(0,s.kt)("p",null,'We can see the structure of the template by consulting the table "templates".'),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"AtomicAsssets mintasset",src:n(462).Z,width:"1181",height:"711"})),(0,s.kt)("p",null,'By consulting the "asset" table and filtering by owner name and NFT ID, we obtain the data of the NFT itself.'),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"AtomicAsssets mintasset",src:n(2714).Z,width:"1170",height:"706"})),(0,s.kt)("p",null,"If you look, some of the information is serialised to save RAM, which makes it difficult to verify the information in the tables. Pink Network has developed an ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/pinknetworkx/eosio-contract-api"},"API service")," to facilitate queries to the NFT database. Some WAX guilds offer redundant replicas of this service for easy access and availability. If we make use of one of those APIs, for example, the one maintained by 3DK Render on testnet, the guild that shares this tutorial, to access the NFT information we can get something like this (depending on the NFT created in our exercise):"),(0,s.kt)("p",null,"Request URL (for the NFT with the ID 1099532298240):"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"https://testatomic.3dkrender.com/atomicassets/v1/1099532298240\n")),(0,s.kt)("p",null,"Outcome of the request:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "success": true,\n  "data": {\n    "contract": "atomicassets",\n    "asset_id": "1099532298240",\n    "owner": "arpegiator21",\n    "is_transferable": true,\n    "is_burnable": true,\n    "collection": {\n      "collection_name": "arpecol11111",\n      "name": "My Great Collection",\n      "img": "QmRVwNbe8wZyjeV37igQsuEfMktJvRv2hkSHqyaaLmfFSi",\n      "author": "arpegiator21",\n      "allow_notify": true,\n      "authorized_accounts": [\n        "blenderizerx",\n        "nftpacker3dk",\n        "atomicdropsx",\n        "arpegiator22",\n        "arpegiator25",\n        "arpegiator21"\n      ],\n      "notify_accounts": ["nftpacker3dk", "arpegiator25"],\n      "market_fee": 0.08,\n      "created_at_block": "146914266",\n      "created_at_time": "1649330195000"\n    },\n    "schema": {\n      "schema_name": "player",\n      "format": [\n        {\n          "name": "name",\n          "type": "string"\n        },\n        {\n          "name": "class",\n          "type": "string"\n        },\n        {\n          "name": "points",\n          "type": "uint32"\n        },\n        {\n          "name": "life",\n          "type": "uint16"\n        },\n        {\n          "name": "lifepoints",\n          "type": "uint16"\n        },\n        {\n          "name": "shield",\n          "type": "uint16"\n        },\n        {\n          "name": "shieldpoints",\n          "type": "uint16"\n        },\n        {\n          "name": "img",\n          "type": "ipfs"\n        }\n      ],\n      "created_at_block": "153820765",\n      "created_at_time": "1652784024500"\n    },\n    "template": {\n      "template_id": "447413",\n      "max_supply": "0",\n      "is_transferable": true,\n      "is_burnable": true,\n      "issued_supply": "1",\n      "immutable_data": {\n        "img": "QmaNCMQ3mD1ZxVPhac6vEUY2pidxwMQC2u6sNwuurweeJ5",\n        "name": "Player A",\n        "class": "Warrior"\n      },\n      "created_at_time": "1653761028000",\n      "created_at_block": "155774695"\n    },\n    "mutable_data": {\n      "life": 100,\n      "points": 0,\n      "shield": 20\n    },\n    "immutable_data": {},\n    "template_mint": "1",\n    "backed_tokens": [],\n    "burned_by_account": null,\n    "burned_at_block": null,\n    "burned_at_time": null,\n    "updated_at_block": "155774752",\n    "updated_at_time": "1653761056500",\n    "transferred_at_block": "155774752",\n    "transferred_at_time": "1653761056500",\n    "minted_at_block": "155774752",\n    "minted_at_time": "1653761056500",\n    "data": {\n      "life": 100,\n      "points": 0,\n      "shield": 20,\n      "img": "QmaNCMQ3mD1ZxVPhac6vEUY2pidxwMQC2u6sNwuurweeJ5",\n      "name": "Player A",\n      "class": "Warrior"\n    },\n    "name": "Player A"\n  },\n  "query_time": 1654083999042\n}\n')),(0,s.kt)("p",null,"As we have already seen, the information about the collection is defined in a record in the collections table, the information that will be repeated in the copies of the same type of NFT is defined in the template and the type of data it can hold is defined in the schema. By not having to repeat all this information in each copy of the NFT, RAM is saved."))}u.isMDXComponent=!0},2714:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/aa_assettable-729e1459400c2a11d74a6403fb8f3c88.png"},7922:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/aa_coltable-3e3553cee54580de8497f3b7b33946f8.png"},7161:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/aa_schematable-e2670641946da24abe5c9e8c5224746d.png"},462:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/aa_templatetable-58839f589dd6bf1f900df7b8c8a048d8.png"},3780:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/atomiassets_mintasset-eff3d96c7c492ebf0bd08b973f8b6d86.png"},4784:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/atomicasset_mintasset-e8c3bf66c15d02a68e65daf09f61bc83.png"},1026:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/atomicassets_tracesmintasset-ee2ec62f768d718ff743324cccda4461.png"}}]);