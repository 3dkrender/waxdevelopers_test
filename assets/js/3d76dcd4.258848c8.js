"use strict";(self.webpackChunkwaxdevelopers=self.webpackChunkwaxdevelopers||[]).push([[4130],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>h});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),m=c(a),p=i,h=m["".concat(l,".").concat(p)]||m[p]||u[p]||s;return a?n.createElement(h,o(o({ref:t},d),{},{components:a})):n.createElement(h,o({ref:t},d))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=a.length,o=new Array(s);o[0]=p;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[m]="string"==typeof e?e:i,o[1]=r;for(var c=2;c<s;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},5295:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var n=a(7462),i=(a(7294),a(3905));const s={title:"Modifying mutable data for AA",nav_order:44,layout:"default",parent:"How-To AtomicAssets",grand_parent:"Tutorials",has_children:!1,"lang-ref":"Modifying mutable data for AA",lang:"en"},o=void 0,r={unversionedId:"tutorials/howto_atomicassets/mutabledata",id:"tutorials/howto_atomicassets/mutabledata",title:"Modifying mutable data for AA",description:"Index",source:"@site/docs/tutorials/howto_atomicassets/mutabledata.md",sourceDirName:"tutorials/howto_atomicassets",slug:"/tutorials/howto_atomicassets/mutabledata",permalink:"/waxdevelopers_test/docs/tutorials/howto_atomicassets/mutabledata",draft:!1,editUrl:"https://github.com/3dkrender/waxdeveloper_test/tree/main/docs/tutorials/howto_atomicassets/mutabledata.md",tags:[],version:"current",frontMatter:{title:"Modifying mutable data for AA",nav_order:44,layout:"default",parent:"How-To AtomicAssets",grand_parent:"Tutorials",has_children:!1,"lang-ref":"Modifying mutable data for AA",lang:"en"},sidebar:"tutorialSidebar",previous:{title:"Minting atomicassets NFTs",permalink:"/waxdevelopers_test/docs/tutorials/howto_atomicassets/mint_nft"},next:{title:"Managing AA schemas",permalink:"/waxdevelopers_test/docs/tutorials/howto_atomicassets/schemas_js"}},l={},c=[{value:"Index",id:"index",level:2},{value:'Mutable data vs. immutable data <a name="p1"></a>',id:"mutable-data-vs-immutable-data-",level:2},{value:'ATTRIBUTE_MAP <a name="p2"></a>',id:"attribute_map-",level:2},{value:'Writing mutable data in an NFT in JavaScript <a name="p3"></a>',id:"writing-mutable-data-in-an-nft-in-javascript-",level:2},{value:'Modifying mutable data in JavaScript <a name="p4"></a>',id:"modifying-mutable-data-in-javascript-",level:2},{value:'Writing the mutable data of an NFT from AtomicAssets in a smart contract <a name="p5"></a>',id:"writing-the-mutable-data-of-an-nft-from-atomicassets-in-a-smart-contract-",level:2},{value:'Modifying mutable data from the smart contract <a name="p6"></a>',id:"modifying-mutable-data-from-the-smart-contract-",level:2}],d={toc:c},m="wrapper";function u(e){let{components:t,...s}=e;return(0,i.kt)(m,(0,n.Z)({},d,s,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"index"},"Index"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#p1"},"Mutable data vs. immutable data")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#p2"},"ATTRIBUTE_MAP")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#p3"},"Writing mutable data in JavaScript")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#p4"},"Modifying mutable data in JavaScript")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#p5"},"Writing mutable data in Smart Contract")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#p6"},"Modifying mutable data in Smart Contract"))),(0,i.kt)("h2",{id:"mutable-data-vs-immutable-data-"},"Mutable data vs. immutable data ",(0,i.kt)("a",{name:"p1"})),(0,i.kt)("p",null,"What makes an NFT a digital valuable? It is their ability to store unchangeable data over all its existence and its permanence in a decentralized system, as a blockchain is. Thanks to the permanence of its immutable data, it is possible to use NFTs as unique, non-forgeable property or authorship records, which is highly appreciated by digital creators who fight against piracy -against the illegitimate usage of their work, to be more specific."),(0,i.kt)("p",null,"However, NFTs have become a popular characteristic of the gaming industry, since they allow the players to become the true owners of the assets they acquire in the game, and to store or trade them even outside the game. We are talking about card collectors, for instance, who still make use of cards from games forgotten decades ago. This could not be achieved in previous digital card games that aimed to replace traditional, physical, card games, since when the game disappeared, its cards disappeared with it. Nowadays, thanks to NFTs, it is possible to keep such cards as if they were part of a traditional card game. There are certain people who believe this is not comparable to the traditional system, but we must be aware that the youngest generations are digital: the vast majority of entertaining content they consume is digital. Therefore, they value digital content as much as our elders value the material."),(0,i.kt)("p",null,"But there is more than storing immutable data for an NFT to be fully useful in a game. This is, in fact, counterproductive, since the asset -which can be a card, a piece of armor or a weapon- should probably be upgraded after a period of time, in order to distinguish itself from other assets, and therefore becoming more valuable. This would not be possible without mutable data."),(0,i.kt)("p",null,"Technically speaking, there is no difference between mutable and immutable data in an NFT: both are information data recorded in the place the NFT occupies in a smart contract. The difference lies in the smart contract's programming logic, which allows mutable data to be modified, while it forbids modifying immutable data."),(0,i.kt)("p",null,"It is true that the smart contract can be modified to avoid this, but this would make it dubious and render it useless."),(0,i.kt)("p",null,"AtomicAssets is the most popular smart contract from WAX Blockchain -as well as other Antelope Blockchains- and is extremely well designed to be used in video games, thus having both mutable and immutable data. We will now learn how to modify this data."),(0,i.kt)("p",null,"Here we can see an example of an NFT -from a card game- with immutable data to the left and mutable data to the right. In this case we can see that the card level (Lvl) can rise, as its \u201cstrong\u201d, \u201cshield\u201d, \u201cloot\u201d and other attributes can."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"AtomicAsssets mintasset",src:a(4390).Z,width:"1373",height:"766"})),(0,i.kt)("p",null,"Let us see how to modify them, now."),(0,i.kt)("h2",{id:"attribute_map-"},"ATTRIBUTE_MAP ",(0,i.kt)("a",{name:"p2"})),(0,i.kt)("p",null,"Before getting into modifying a mutable field In JavaScript it is important to know the ATTRIBUTE_MAP object. One of the advantages of the AtomicAssets standard is the use of serialization in order to save RAM in the tables which store NFTs' data. For this we use a data map that pairs the type of data with its content, therefore allowing it to be serialized."),(0,i.kt)("p",null,"This map's format is built following this pattern:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[{"key": MYKEY, value: MYVALUE}, ...]\n')),(0,i.kt)("p",null,'In an NFT\'s template it is defined which is mutable data and which is immutable data, and it specifies the name of the field and the type of data it will contain. Therefore, we can have the string type field "name", or the int(16bits) type field "speed".'),(0,i.kt)("p",null,"So if we wished to create a data map to specify this information:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},"{ \n    name: \u201cDelorean\u201d, \n    speed: 300 \n}\n")),(0,i.kt)("p",null,"We should create an array of objects while keeping its specifications from the template:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},"[{\n    \u201ckey\u201d: \u201cname\u201d,\n    \u201cvalue\u201d: [\u201cstring\u201d, \u201cDelorean\u201d]\n}, {\n    \u201ckey\u201d: \u201cspeed\u201d,\n    \u201cvalue\u201d: [\u201cuint16\u201d, 300]\n}]\n")),(0,i.kt)("p",null,"Let us see how to do this in JavaScript now."),(0,i.kt)("h2",{id:"writing-mutable-data-in-an-nft-in-javascript-"},"Writing mutable data in an NFT in JavaScript ",(0,i.kt)("a",{name:"p3"})),(0,i.kt)("p",null,'For this example we need to call the "setassetdata" action from the AtomicAssets\' smart contract. This action requires of four parameters:'),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"AtomicAsssets mintasset",src:a(2671).Z,width:"521",height:"432"})),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"authorized_editor"),": the name of the account which must be authorized to access the collection the NFT belongs to."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"asset_owner"),": the name of the account belonging to the current owner of the asset -it is not necessary to be the owner of the asset in order to modify its mutable data; you just need to be authorized to do so, or be its creator."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"asset_id"),": the ID number of the NFT we want to modify."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"new_mutable_data"),": a structure similar to the ATTRIBUTE_MAP which contains the data we want to modify, as we saw before.")),(0,i.kt)("p",null,'By following the previous example we could define a function which receives the needed information as parameters and which calls the smart contract from "atomicassets":'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"Const updateNft = (authorized, owner, asset_id, name, speed) => {\n    apiRpc.transact({\n        actions: [{\n            account: 'atomicassets',\n            name: 'setassetdata',\n            authorization: [{\n                actor: authorized,\n                permission: 'active'\n            }],\n            data: {\n                authorized_editor: authorized,\n                asset_owner: owner,\n                asset_id: asset_id,\n                new_mutable_data: [{\n                    'key': 'name',\n                    'value': [\"string\", name]\n                },\n                {\n                    'key': 'speed',\n                    'value': ['uint16', speed]\n                }]\n            }\n        }]\n    }, {\n        blocksBehind: 3,\n        expireSeconds: 30,\n    }).then(result => {\n        log(result);\n    }).catch(err => {\n        console.log(err, JSON.stringify(err, null, 2));\n    });\n}\n")),(0,i.kt)("h2",{id:"modifying-mutable-data-in-javascript-"},"Modifying mutable data in JavaScript ",(0,i.kt)("a",{name:"p4"})),(0,i.kt)("p",null,"We have seen how to introduce mutable data in an NFT, but sometimes we will need to update its content, such as, for instance, to add a number of points to its actual score."),(0,i.kt)("p",null,"Obviously, we will first need to read the field's content, but we should keep in mind that the data is serialized, as we mentioned earlier. If we use the eosjs library, we will have to deserialize the information first. Fortunately, the Pink Network team, creators of the AtomicAssets standard, also created a JavaScript library in order for us to access all collections, schemes, templates and, of course, NFTs, in a much easier way."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/atomicassets"},"https://www.npmjs.com/package/atomicassets")),(0,i.kt)("p",null,"As the eosjs library requires to be connected to a Full Story API from the WAX Blockchain, the AtomicAssets library needs to be connected to a specific Atomic API. There are several WAX Block producers who offer this service, fortunately, and it is free for WAX Blockchain users."),(0,i.kt)("strong",null,"Note:")," If you are developing an application for public use it is convenient to have your own APIs and not depend on the availability of public APIs. :::",(0,i.kt)("p",null,"In this example we see how to connect to an Atomic API in order to read an NFT, based on its ID, and how to obtain one of its data's contents."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const { ExplorerApi } = require("atomicassets");\nconst api = new ExplorerApi(\n    ATOMIC_API, \n    "atomicassets", \n    { fetch });\n\nconst asset = await api.getAsset(asset_id);\nlet player_points = asset.mutable_data.player_points;\nplayer_points += 100;\n')),(0,i.kt)("p",null,"You must change ",(0,i.kt)("strong",{parentName:"p"},"ATOMIC_API")," for a valid Atomic API URL. You can get a list of them in ",(0,i.kt)("a",{parentName:"p",href:"https://tools.ledgerwise.io"},"https://tools.ledgerwise.io")),(0,i.kt)("p",null,"Once we have read it, all there is left to do is to update the information with the desired values and save it in the NFT, as we saw in the previous step."),(0,i.kt)("h2",{id:"writing-the-mutable-data-of-an-nft-from-atomicassets-in-a-smart-contract-"},"Writing the mutable data of an NFT from AtomicAssets in a smart contract ",(0,i.kt)("a",{name:"p5"})),(0,i.kt)("p",null,'Operating with AtomicAssets\' NFTs from our smart contract requires us to include some items from the smart contract "atomicassets" in our code, for us to be able to reuse certain definitions and declarations of functions and data . Specifically we will need these files:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"atomicassets.hpp\natomicdata.hpp\nbase58.hpp\n")),(0,i.kt)("p",null,"Which we can obtain from Pink Network's GitHub:\n(",(0,i.kt)("a",{parentName:"p",href:"https://github.com/pinknetworkx/atomicassets-contract/tree/master/include"},"https://github.com/pinknetworkx/atomicassets-contract/tree/master/include"),")"),(0,i.kt)("p",null,"Our first step is to declare an item of the ATTRIBUTE_MAP type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"atomicassets::ATTRIBUTE_MAP mdata = {};\n")),(0,i.kt)("p",null,"Now we can start adding data:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"mdata[\u201cname\u201d] = string(\u201cDelorean\u201d);\nmdata[\u201cspeed\u201d] = uint16_t(300);\n")),(0,i.kt)("p",null,"Or, if we receive the data as parameters in a function -see the JavaScript example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"mdata[\u201cname\u201d] = name;\nmdata[\u201cspeed\u201d] = speed;\n")),(0,i.kt)("p",null,'And all that is left to do is to call the "atomicassets" smart contract\'s action to carry out the operation:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'action(\n    permission_level{name(\u201cauthorized\u201d), name("active")},\n    name(\u201catomicassets\u201d),\n    name("setassetdata"),\n    make_tuple(name(\u201cauthorized\u201d), name(\u201cowner\u201d), asset_id, mdata))\n    .send();\n')),(0,i.kt)("h2",{id:"modifying-mutable-data-from-the-smart-contract-"},"Modifying mutable data from the smart contract ",(0,i.kt)("a",{name:"p6"})),(0,i.kt)("p",null,'While similar to the JavaScript example of mutable data modification, in this case we will need to deserialize the data. We are fortunate that Pink Network will facilitate our job again -this is the reason why we imported the "atomicdata" and "base58" files during the previous step.'),(0,i.kt)("p",null,"First of all we need to locate the NFT by accessing the assets table owned by the current owner. This is why it is important to know who has the NFT in their wallet, since it will be the scope of the data table of the assets from AtomicAssets."),(0,i.kt)("p",null,"The information we need to serialize and deserialize the data -item names and data types- is stored in the collection's schema, so we need to access the information of the schema the NFT belongs to as well."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Read owner\u2019s assets\natomicassets::assets_t listAssets = atomicassets::get_assets(owner);\n\n// Search for the NFT based on its ID number\nauto idxCard = listAssets.find(asset_id);\n\n// Access the schemas table of the asset\u2019s collection\natomicassets::schemas_t collection_schemas = atomicassets::get_schemas(idxCard->collection_name);\n\n// Obtain the asset\u2019s schemas to learn the data types\nauto idxSchema = collection_schemas.find(idxCard->schema_name.value);\n\n// Deserialize the data\nmdata = atomicdata::deserialize(\n       idxCard->mutable_serialized_data,\n       idxSchema->format);\n\n// Access the data we wish to modify\nuint32_t mdata_player_points = get<uint32_t>(mdata["player_points"]);\n\n// Update\nmdata_player_points += player_points;\n')),(0,i.kt)("p",null,'Once the data has been taken we can modify and store it as we saw in the previous example. We just need to keep in mind that the function "deserialize" will give us an item of the type ATTRIBUTE_MAP, which allows us to use it directly in the writing operation.'))}u.isMDXComponent=!0},4390:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/mutabledata_aa-904353c72119cd95e09f95a2d76c27ce.png"},2671:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/setassets_aa-4ff3d7a60be6d5127f70c57a24ec2cf0.png"}}]);