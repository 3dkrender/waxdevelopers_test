"use strict";(self.webpackChunkwaxdevelopers=self.webpackChunkwaxdevelopers||[]).push([[1017],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>g});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=u(n),d=r,g=m["".concat(s,".").concat(d)]||m[d]||p[d]||i;return n?a.createElement(g,o(o({ref:t},c),{},{components:n})):a.createElement(g,o({ref:t},c))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:r,o[1]=l;for(var u=2;u<i;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8923:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const i={title:"Build Your Contract to call WAX RNG contract",layout:"default",nav_order:84,parent:"Create a WAX RNG Smart Contract",grand_parent:"Tutorials","lang-ref":"Build Your Contract to call WAX RNG contract",lang:"en"},o=void 0,l={unversionedId:"tutorials/create-wax-rng-smart-contract/rng_sample",id:"tutorials/create-wax-rng-smart-contract/rng_sample",title:"Build Your Contract to call WAX RNG contract",description:"In this example, we'll create a smart contract that uses the WAX RNG service to generate a random number no larger than 100. This number gets written to a multiindex table, along with an internal Customer ID, the customer's signingvalue, and the checksum256 random_value returned from the WAX RNG oracle.",source:"@site/docs/tutorials/create-wax-rng-smart-contract/rng_sample.md",sourceDirName:"tutorials/create-wax-rng-smart-contract",slug:"/tutorials/create-wax-rng-smart-contract/rng_sample",permalink:"/waxdevelopers_test/docs/tutorials/create-wax-rng-smart-contract/rng_sample",draft:!1,editUrl:"https://github.com/wax-office-of-inspector-general/wax-developer/tree/main/docs/tutorials/create-wax-rng-smart-contract/rng_sample.md",tags:[],version:"current",frontMatter:{title:"Build Your Contract to call WAX RNG contract",layout:"default",nav_order:84,parent:"Create a WAX RNG Smart Contract",grand_parent:"Tutorials","lang-ref":"Build Your Contract to call WAX RNG contract",lang:"en"},sidebar:"tutorialSidebar",previous:{title:"Deploy Your WAX RNG Contract",permalink:"/waxdevelopers_test/docs/tutorials/create-wax-rng-smart-contract/rng_deploy"},next:{title:"Test Your WAX RNG Contract",permalink:"/waxdevelopers_test/docs/tutorials/create-wax-rng-smart-contract/rng_test"}},s={},u=[{value:"Create Your Contract",id:"create-your-contract",level:2},{value:"Compiling the smart contract",id:"compiling-the-smart-contract",level:2}],c={toc:u},m="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In this example, we'll create a smart contract that uses the WAX RNG service to generate a random number no larger than 100. This number gets written to a multi_index table, along with an internal Customer ID, the customer's signing_value, and the checksum256 random_value returned from the WAX RNG oracle."),(0,r.kt)("p",null,"To provide fairness, provability, and user confidence, it's recommended that you allow the customer to view or even edit the client-side signing_value. If you prefer to generate the signing_value on the back-end or your app doesn't require a front-end signing_value, you could use the user's transaction hash sent from their wallet. This value is a sha256 hash signed by the client that must be reduced to a 64-bit data."),(0,r.kt)("p",null,"By reducing the 256-bit hash to a 64-bit portion, we may find that it is not a unique code. The number we send as a seed for random number generation must be unique, i.e. it must not have been used before for another random number request. For this we can query the WAX RNG smart contract and check if our candidate seed is unique or has already been used."),(0,r.kt)("p",null,"To perform this check we will need to access the ",(0,r.kt)("em",{parentName:"p"},"signvals.a")," table of the WAX RNG smart contract. To facilitate this we will add the ",(0,r.kt)("em",{parentName:"p"},"wax-orng-interface.hpp")," file to our smart contract and link it in our header file:"),(0,r.kt)("h2",{id:"create-your-contract"},"Create Your Contract"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"From the command line, navigate to your smart contracts directory. For this example, we'll use ",(0,r.kt)("strong",{parentName:"p"},"mycontracts"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Use ",(0,r.kt)("strong",{parentName:"p"},"eosio-init")," with the ",(0,r.kt)("inlineCode",{parentName:"p"},"-project")," parameter to create your smart contract template."),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"$ eosio-init -project rngtest"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"From your smart contracts folder, open ",(0,r.kt)("strong",{parentName:"p"},"rngtest/include/rngtest.hpp")," and paste the following:"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},'#include <eosio/eosio.hpp>\n\n#include <eosio/crypto.hpp>\n#include <eosio/transaction.hpp>\n\n#include <wax-orng-interface.hpp>\n\n#define ORNG_CONTRACT name("orng.wax")\n\nusing namespace eosio;\nusing namespace std;\n\nCONTRACT rngtest : public contract {\n   public:\n      using contract::contract;\n\n      // actions available\n      ACTION getrnd( name& customer_id );\n      ACTION receiverand(uint64_t signing_value, const checksum256& random_value);\n\n      //table structure\n      TABLE rngcustomers_table{\n         uint64_t signing_value;\n         name customer_id;\n         checksum256 random_value;\n         uint8_t final_number;\n\n         uint64_t primary_key() const { return signing_value; }\n      };\n      //define table based on table structure\n      typedef multi_index<"rngcustomers"_n, rngcustomers_table> rngcustomers_index;\n\n      // action wrappers\n      using getrnd_action = action_wrapper<"getrnd"_n, &rngtest::getrnd>;\n      using receiverand_action = action_wrapper<"receiverand"_n, &rngtest::receiverand>;\n\n      // Set table \'rngcustomers\'\n      rngcustomers_index _customers = rngcustomers_index(get_self(), get_self().value);\n};\n')),(0,r.kt)("p",null,"We will work with cryptographic functions and checksum256 data, so we include the ",(0,r.kt)("inlineCode",{parentName:"p"},"crypto.hpp")," library."),(0,r.kt)("p",null,"We will capture the ",(0,r.kt)("em",{parentName:"p"},"transaction_id")," of the transaction calling the smart contract, so we include the ",(0,r.kt)("inlineCode",{parentName:"p"},"transaction.hpp")," library."),(0,r.kt)("p",null,"As mentioned above, to access the table of values used by WAX RNG to generate the random numbers, we include the definition file ",(0,r.kt)("inlineCode",{parentName:"p"},"wax-orng-interface.hpp"),". We include the source code of the file in ",(0,r.kt)("inlineCode",{parentName:"p"},"rngtest/include/wax-rng-interface.hpp"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},'#include <eosio/eosio.hpp>\n\nusing namespace eosio;\n\nnamespace orng {\n\n    static constexpr name ORNG_CONTRACT = name("orng.wax");\n\n    TABLE signvals_a {\n        uint64_t signing_value;\n\n        auto primary_key() const { return signing_value; }\n    };\n    typedef multi_index <name("signvals.a"), signvals_a> signvals_t;\n\n    signvals_t signvals = signvals_t(ORNG_CONTRACT, ORNG_CONTRACT.value);\n}\n')),(0,r.kt)("p",null,"We declare ",(0,r.kt)("inlineCode",{parentName:"p"},"rngcustomers")," as a multi-index data structure to temporarily store the data required to call to WAX RNG and to store the random number returned for later use in the task for which we have requested it."),(0,r.kt)("p",null,"We declare the actions that we are going to use in our example and that we will explain later."),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},"We begin to edit the code of the smart contract in the file ",(0,r.kt)("strong",{parentName:"li"},"src/rngtest.cpp"),".")),(0,r.kt)("p",null,"We begin with the inclusion of the header file"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"#include <rngtest.hpp>\n")),(0,r.kt)("p",null,"And we will add the following functions:"),(0,r.kt)("p",null,"4.1 ACTION getrnd"),(0,r.kt)("p",null,"This action captures the ",(0,r.kt)("em",{parentName:"p"},"transaction_id")," of the transaction that has called the smart contract to generate a unique number that will serve as a seed for the call to WAX RNG."),(0,r.kt)("p",null,"In addition, it will store in the ",(0,r.kt)("inlineCode",{parentName:"p"},"rngcustomers")," table the auxiliary data to be able to receive the random number from WAX RNG and to be able to recognize it among different requests."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Sample"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"customer_id"),(0,r.kt)("td",{parentName:"tr",align:null},"name"),(0,r.kt)("td",{parentName:"tr",align:null},"arpegiator21"),(0,r.kt)("td",{parentName:"tr",align:null},"Name of the user making the request")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},'ACTION rngtest::getrnd( name& customer_id ) {\n   require_auth(customer_id);\n\n   // Read transaction_id\n   size_t size = transaction_size();\n   char buf[size];\n   uint32_t read = read_transaction(buf, size);\n   check(size == read, "Signing value generation: read_transaction() has failed.");\n   checksum256 tx_id = eosio::sha256(buf, read);\n\n   // Get first 64 bits from transaction_id\n   uint64_t signing_value;\n   memcpy(&signing_value, tx_id.data(), sizeof(signing_value));\n\n   // Check if signing_value is valid...\n   auto iSigningValue = orng::signvals.begin();\n   uint8_t c = 0;\n\n   while( iSigningValue != orng::signvals.end() && c < 64){\n      iSigningValue = orng::signvals.find(signing_value);\n\n      // If signing_value exists, we rotate 1 bit to modify the hash. There are 64 possible variations...\n      if(iSigningValue != orng::signvals.end()){\n         signing_value <<= 1;\n         c++;\n      }\n   }\n\n   // Ok, I don\'t think this will happen but... what if it does?\n   check(c < 64, "No combination was valid? Inconceivable!");\n\n   // Prepare the table where the random value will be received.\n   _customers.emplace(get_self(), [&](auto& rec) {\n      rec.signing_value = signing_value;\n      rec.customer_id = customer_id;\n   });\n\n   // Call to orng.wax smart contract\n   action(\n      { get_self(), "active"_n },\n      "orng.wax"_n,\n      "requestrand"_n,\n      std::tuple{ signing_value, signing_value, get_self() })\n      .send();\n}\n')),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"transaction_id")," is a unique number but since we have to select only a 64-bit portion it is possible that the resulting value is not unique. For that reason we perform the check against the ",(0,r.kt)("inlineCode",{parentName:"p"},"signvals.a")," table and, if the result is a number already chosen, we perform a 1-bit rotation to try again."),(0,r.kt)("p",null,"When we are certain that we have found a unique number, we store the number, along with the user's name, and call WAX RNG by sending it the seed (",(0,r.kt)("em",{parentName:"p"},"signing_value"),") and the same value as the call identifier. We could use the user's own name as the identifier (",(0,r.kt)("em",{parentName:"p"},"customer_id.value"),") but this would complicate the code in case a user requests several random numbers and his requests are simultaneously stored in the table ",(0,r.kt)("inlineCode",{parentName:"p"},"rngcustomers")," whose primary key is ",(0,r.kt)("em",{parentName:"p"},"signing_value"),"."),(0,r.kt)("p",null,"4.2. ACTION receiverand"),(0,r.kt)("p",null,"Callback action that will be called from WAX RNG to return us, in case of success, the random number, together with the code that we provide as identifier of the request (",(0,r.kt)("em",{parentName:"p"},"signing_value"),")."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"signing_value"),(0,r.kt)("td",{parentName:"tr",align:null},"uint64_t"),(0,r.kt)("td",{parentName:"tr",align:null},"Code sent as identifier.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"random_value"),(0,r.kt)("td",{parentName:"tr",align:null},"checksum256"),(0,r.kt)("td",{parentName:"tr",align:null},"Hash code generated by WAX RNG that we will use to obtain the random number")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},'ACTION rngtest::receiverand(uint64_t signing_value, const checksum256& random_value) {\n   require_auth(ORNG_CONTRACT);\n\n   //cast the random_value to a smaller number\n   uint64_t max_value = 100;\n   auto byte_array = random_value.extract_as_byte_array();\n\n   uint8_t random_int = 0;\n   random_int = byte_array[0];\n\n   uint8_t num1 = random_int % max_value;\n\n   auto iCustomers = _customers.require_find(signing_value, "Error: Petition not found!");\n\n   // update table with random_value\n   _customers.modify(iCustomers, get_self(), [&](auto& rec) {\n      rec.random_value = random_value;\n      rec.final_number = num1;\n   });\n}\n')),(0,r.kt)("p",null,"We make sure that only WAX RNG will be able to call this action with ",(0,r.kt)("em",{parentName:"p"},"require_auth"),"."),(0,r.kt)("p",null,"We extract the first 8 bits of the returned random number and use it to get a number no larger than 100. "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note:")," We still have many bits available in case we need to get more random numbers!\n:::"),(0,r.kt)("p",null,"We locate the record associated with the request identifier and update its contents to store the returned hash code."),(0,r.kt)("p",null,"We can now use the random value from the client to perform the function for which we requested it."),(0,r.kt)("h2",{id:"compiling-the-smart-contract"},"Compiling the smart contract"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"From the console we go to the ",(0,r.kt)("strong",{parentName:"li"},"rngtest/build")," folder and execute the following commands:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"cmake ..\nmake\n```\n\nWe will find the files **rngtest.wasm** and **rngtest.abi** in the **rngtest/build/rngtest** folder.\n")))}p.isMDXComponent=!0}}]);