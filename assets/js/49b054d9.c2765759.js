"use strict";(self.webpackChunkwaxdevelopers=self.webpackChunkwaxdevelopers||[]).push([[2246],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>d});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),i=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=i(e.components);return n.createElement(l.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,m=c(e,["components","mdxType","originalType","parentName"]),h=i(a),p=r,d=h["".concat(l,".").concat(p)]||h[p]||u[p]||s;return a?n.createElement(d,o(o({ref:t},m),{},{components:a})):n.createElement(d,o({ref:t},m))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,o=new Array(s);o[0]=p;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c[h]="string"==typeof e?e:r,o[1]=c;for(var i=2;i<s;i++)o[i]=a[i];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},1642:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>c,toc:()=>i});var n=a(7462),r=(a(7294),a(3905));const s={title:"Managing AA schemas",nav_order:36,layout:"default",parent:"How-To AtomicAssets",grand_parent:"Tutorials",has_children:!1,"lang-ref":"Managing AA schemas",lang:"en"},o=void 0,c={unversionedId:"tutorials/howto_atomicassets/schemas_js",id:"tutorials/howto_atomicassets/schemas_js",title:"Managing AA schemas",description:"As mentioned above, schemas allow us to declare the common characteristics of the NFTs in our collection and to create groups. If we are creating NFTs for a game that has several characters, each character will be unique, but will share attributes with the rest of the characters. All the characters will have a name, a score, a life point level, etc.",source:"@site/docs/tutorials/howto_atomicassets/schemas_js.md",sourceDirName:"tutorials/howto_atomicassets",slug:"/tutorials/howto_atomicassets/schemas_js",permalink:"/waxdevelopers_test/docs/tutorials/howto_atomicassets/schemas_js",draft:!1,editUrl:"https://github.com/wax-office-of-inspector-general/wax-developer/tree/main/docs/tutorials/howto_atomicassets/schemas_js.md",tags:[],version:"current",frontMatter:{title:"Managing AA schemas",nav_order:36,layout:"default",parent:"How-To AtomicAssets",grand_parent:"Tutorials",has_children:!1,"lang-ref":"Managing AA schemas",lang:"en"},sidebar:"tutorialSidebar",previous:{title:"Modifying mutable data for AA",permalink:"/waxdevelopers_test/docs/tutorials/howto_atomicassets/mutabledata"},next:{title:"Managing AA Templates",permalink:"/waxdevelopers_test/docs/tutorials/howto_atomicassets/templates_js"}},l={},i=[{value:"Create a schema",id:"create-a-schema",level:2},{value:"Extend a scheme",id:"extend-a-scheme",level:2}],m={toc:i},h="wrapper";function u(e){let{components:t,...s}=e;return(0,r.kt)(h,(0,n.Z)({},m,s,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"As mentioned above, schemas allow us to declare the common characteristics of the NFTs in our collection and to create groups. If we are creating NFTs for a game that has several characters, each character will be unique, but will share attributes with the rest of the characters. All the characters will have a name, a score, a life point level, etc. "),(0,r.kt)("p",null,"Likewise, our game will have weapons and all of them will share attributes such as name, damage point value, durability points, etc."),(0,r.kt)("p",null,"By making use of the schemes we will be able to create groups that will facilitate the classification and subsequent manipulation of each of the NFTs in our collection."),(0,r.kt)("p",null,"AtomicAssets incorporates the following actions to manage the schemes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"createschema: Create the schema and declare the data types that compose it."),(0,r.kt)("li",{parentName:"ul"},"extendschema: Add more datatypes to an existing schema")),(0,r.kt)("h2",{id:"create-a-schema"},"Create a schema"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"AtomicAsssets createschema",src:a(5952).Z,width:"461",height:"405"})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"authorized_creator: Name of an account authorised to manipulate the collection. The action must be signed by this account."),(0,r.kt)("li",{parentName:"ul"},"collection_name: Name of the collection we are managing."),(0,r.kt)("li",{parentName:"ul"},"schema_name: Name we assign to the schema."),(0,r.kt)("li",{parentName:"ul"},"schema_format: Array of types ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/pinknetworkx/atomicassets-contract/wiki/Custom-Types#format"},"FORMAT")," that declare the structure of the schema.")),(0,r.kt)("p",null,"We will create a schema for the player cards with the following attributes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Name: string"),(0,r.kt)("li",{parentName:"ul"},"Class: string"),(0,r.kt)("li",{parentName:"ul"},"Points: uint32"),(0,r.kt)("li",{parentName:"ul"},"Life: uint16"),(0,r.kt)("li",{parentName:"ul"},"Life points: uint16")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Collection author\nconst auth = \'arpegiator21\';\n\n// Collection name (eosio name format)\nconst colName = \'arpecol11111\';\n\n// Schema name\nconst schemaName = \'player\';\n\n// Collection description\nconst schemaFormat = [\n    {\n        "name": "name",\n        "type": "string",\n    },\n    {\n        "name": "img",\n        "type": "ipfs",\n    },\n    {\n        "name": "class",\n        "type": "string",\n    },\n    {\n        "name": "points",\n        "type": "uint32",\n    },\n    {\n        "name": "life",\n        "type": "uint16",\n    },\n    {\n        "name": "lifepoints",\n        "type": "uint16",\n    },\n];\n\n// Create schema\n(async()=> {\n    const result = await createSchema(auth, colName, schemaName, schemaFormat);\n    console.log(result);\n})();\n')),(0,r.kt)("p",null,"And call to action:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'/* \n * Create a schema into an AtomicAssets collection\n */\nconst createSchema = async ( \n  auth,\n  colName,\n  schemaName,\n  schemaFormat\n) => {\n  try {\n    const result = await apiRpc.transact(\n      {\n        actions: [\n          {\n            account: "atomicassets",\n            name: "createschema",\n            authorization: [\n              {\n                actor: auth,\n                permission: "active",\n              },\n            ],\n            data: {\n              authorized_creator: auth,\n              collection_name: colName,\n              schema_name: schemaName,\n              schema_format: schemaFormat\n            },\n          },\n        ],\n      }, TAPOS\n    );\n    return result;\n  } catch (error) {\n    console.log(error);\n    return false;\n  }\n}\n')),(0,r.kt)("h2",{id:"extend-a-scheme"},"Extend a scheme"),(0,r.kt)("p",null,'After creating the schema we realise that a character in the game will be exposed to dangers and should be protected by armour. We cannot modify attributes that already exist in a schema, but we can add new attributes with the action "',(0,r.kt)("em",{parentName:"p"},"extendschema"),'".'),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"AtomicAsssets createschema",src:a(3626).Z,width:"458",height:"398"})),(0,r.kt)("p",null,"This is the new data we will add to the schema:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Armour: uint16"),(0,r.kt)("li",{parentName:"ul"},"Armour points: uint16")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Collection editor\nconst auth = \'arpegiator21\';\n\n// Collection name (eosio name format)\nconst colName = \'arpecol11111\';\n\n// Schema name\nconst schemaName = \'player\';\n\n// Collection description\nconst schemaFormatExtend = [\n    {\n        "name": "shield",\n        "type": "uint16",\n    },\n    {\n        "name": "shieldpoints",\n        "type": "uint16",\n    }\n];\n\n// Create schema\n(async()=> {\n    const result = await extendSchema(auth, colName, schemaName, schemaFormatExtend);\n    console.log(result);\n})();\n')),(0,r.kt)("p",null,"And call to action:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'/* \n * Extend a schema with new data types\n */\nconst extendSchema = async ( \n  auth,\n  colName,\n  schemaName,\n  schemaFormatExtend\n) => {\n  try {\n    const result = await apiRpc.transact(\n      {\n        actions: [\n          {\n            account: "atomicassets",\n            name: "extendschema",\n            authorization: [\n              {\n                actor: auth,\n                permission: "active",\n              },\n            ],\n            data: {\n              authorized_editor: auth,\n              collection_name: colName,\n              schema_name: schemaName,\n              schema_format_extension: schemaFormatExtend\n            },\n          },\n        ],\n      }, TAPOS\n    );\n    return result;\n  } catch (error) {\n    console.log(error);\n    return false;\n  }\n}\n')))}u.isMDXComponent=!0},5952:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/createschema_atomicassets-c512f321b75078e6e2a7c6f829d69cc9.png"},3626:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/extendschema_atomicassets-1ec20377b988e5fe2499c3b8a8768bb3.png"}}]);